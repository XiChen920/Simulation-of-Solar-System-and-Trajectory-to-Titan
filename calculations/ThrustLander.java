package phase3.calculations;

import phase3.input.ArtificialSpaceObject;

/**
 * A class which holds multiple formula's needed for calculating thrust
 *
 *
 *
 */
public class ThrustLander {
	
	/*
	 * left and right thruster use magnetoPlasmaDynamic system, main thruster uses APS
	 */
	
	//side thrusters
	private static final double[] magnetoPlasmaDynamicThrustRange = {2.5, 25.0}; //Newtons
	private static final double[] magnetoPlasmaDynamicVERange = {15.0, 60.0};	//meters per second
	
	//main thrusters
	private static final double[] apsThrustRange = {0, 16000};//Newtons
	private static final double[] apsVERange = {0, 2000};

	//0 = left thruster, 1 = main thruster, 2 = right thruster
	private static double[] currentForceThrusters = {0, 0, 0};
	private static double[] currentMassFlowrate = {0, 0, 0};

	
	
	private static double apsEffectiveVelocity(double f) {
		double dAPS = (16000/2000);
		return f/dAPS;
	}
	
	private static double mpdEffectiveVelocity(double f) {
		double dMPD = ((25.0-2.5)/(60.0-15.0));;
		return f/dMPD;
	}
	
	private static double calculateMassFlowrate(double f, double ve) {
		if(ve == 0) {
			return 0;
		}
		return f/ve;
	}

	private static void calculateCurrentMassFlowrate() {
		double veleft = mpdEffectiveVelocity(currentForceThrusters[0]);
		double vemain = apsEffectiveVelocity(currentForceThrusters[1]);
		double veright = mpdEffectiveVelocity(currentForceThrusters[2]);
		double mdotleft = calculateMassFlowrate(currentForceThrusters[0], veleft);
		double mdotmain = calculateMassFlowrate(currentForceThrusters[1], vemain);
		double mdotright = calculateMassFlowrate(currentForceThrusters[2], veright);
		
		double[] mdot = {mdotleft, mdotmain, mdotright};
		currentMassFlowrate = mdot;	
	}

	
	
	/**
	 * 
	 * @param F1 initial force applied
	 * @param F2 force applied after a passage of time
	 * @return force needed to be generated in order to reach F2, coming from F1
	 */
	public static Vector2d calculateImpulseForce(Vector2d F1, Vector2d F2) {
		return (Vector2d) F2.sub(F1);
	}
	
	/**
	 * 
	 * @param v1 initial exit velocity of space craft
	 * @param v2 final exit velocity of space craft
	 * @return force needed to be generated in order to reach v2, coming from v1
	 */
	public static Vector2d calculateImpulseExitVelocity(Vector2d ve1, Vector2d ve2) {
		Vector2d F1 = calculateThrustForce(ve1);
		Vector2d F2 = calculateThrustForce(ve2);
		return calculateImpulseForce(F1,F2);
	}
	
	/**
	 * 
	 * @param ve exit velocity
	 * @return thrust generated at a specific moment
	 */
	public static Vector2d calculateThrustForce(Vector2d ve) {
		Vector2d exitVelocity = ve; //e.g. 22000
		Vector2d force = (Vector2d) exitVelocity.mul(Constants.getMassFlowRate());
		return force;
	}
	
	/**
	 * 
	 * @param I			
	 * @param netMass	
	 * @return
	 */
	public static Vector2d calculateThrustVelocity(Vector2d I, double netMass) {
		Vector2d impulse = new Vector2d(I);
		return (Vector2d) impulse.mul(1/netMass);
	}
	
	/**
	 * 
	 * @param F1
	 * @param F2
	 * @param netMass
	 * @return
	 */
	
	public static Vector2d calculateThrustVelocity_F(Vector2d F1, Vector2d F2, double netMass) {
		Vector2d impulse = calculateImpulseForce(F1, F2);
		return (Vector2d) impulse.mul(1/netMass);
	}
	
	/**
	 * 
	 * @param ve1
	 * @param ve2
	 * @param netMass
	 * @return
	 */
	public static Vector2d calculateThrustVelocity_ve(Vector2d ve1, Vector2d ve2, double netMass) {
		Vector2d impulse = calculateImpulseExitVelocity(ve1, ve2);
		return (Vector2d) impulse.mul(1/netMass);
	}
	
	/**
	 * calculate final velocity by adding effective velocity to the initial velocity of the space craft
	 * @param v1		initial velocity of space craft after gravitational forces have enacted upon it
	 * @param ve		effective velocity provided by thrust
	 * @return velocity after gravity and impulse
	 */
	public static Vector2d calculateFinalVelocity_ve(Vector2d v1, Vector2d ve) {
		Vector2d initialVelocity = new Vector2d(v1);
		Vector2d impulse = new Vector2d(ve);
		return (Vector2d) initialVelocity.add(ve);
	}
	
	/**
	 * calculate final velocity based on a specific impulse generated by thrusters and on the netMass
	 * @param v1		initial velocity of space craft after gravitational forces have enacted upon it
	 * @param I			impulse generated by space craft	
	 * @param netMass	net mass of space craft
	 * @return velocity after gravity and impulse
	 */
	public static Vector2d calculateFinalVelocity_impulse(Vector2d v1, Vector2d I, double netMass) {
		Vector2d initialVelocity = new Vector2d(v1);
		Vector2d impulse = new Vector2d(I);
		return (Vector2d) initialVelocity.add(impulse.mul(1/netMass));
	}
	
	/**
	 * 
	 * @param v1		initial velocity of space craft after gravitational forces have enacted upon it
	 * @param F1		initial force of thrusters
	 * @param F2 		final force of thrusters	
	 * @param netMass	net mass of space craft
	 * @return velocity after gravity and impulse
	 */
	public static Vector2d calculateFinalVelocity_F(Vector2d v1, Vector2d F1, Vector2d F2, double netMass) {
		Vector2d initialVelocity = new Vector2d(v1);
		Vector2d impulse = calculateImpulseForce(F1, F2);
		return (Vector2d) initialVelocity.add(impulse.mul(1/netMass));
	}
	
	/**
	 * @param v1 		initial velocity of spacecraft
	 * @param ve1		initial exit velocity of mass after gravitational forces have enacted upon it
	 * @param ve2 		target exit velocity of mass to be reached 	
	 * @param netMass	net mass of space craft
	 * @return velocity after gravity and impulse
	 */
	public static Vector2d calculateFinalVelocity_ve(Vector2d v1, Vector2d ve1, Vector2d ve2, double netMass) {
		Vector2d initialVelocity = new Vector2d(ve1);
		Vector2d impulse = calculateImpulseExitVelocity(ve1, ve2);
		return (Vector2d) initialVelocity.add(impulse.mul(1/netMass));
	}
	
	public static Vector2d calculateFinalAcceleration(Vector2d ve1, Vector2d ve2, double stepsize) {
		Vector2d exitVelocity1 = new Vector2d(ve1);
		Vector2d exitVelocity2 = new Vector2d(ve2);
		Vector2d dv = (Vector2d) exitVelocity2.sub(exitVelocity1);
		return (Vector2d) dv.mul(1/stepsize);
	}

	
	public static double[] getCurrentMassFlowrate() {
		return currentMassFlowrate;
	}




	public static double[] getCurrentForceThrusters() {
		ThrustLander.calculateCurrentMassFlowrate();
		return currentForceThrusters;
		
	}




	public static void setCurrentForceThrusters(double[] currentForceThrusters) {
		ThrustLander.currentForceThrusters = currentForceThrusters;
		ThrustLander.calculateCurrentMassFlowrate();
	}

}
